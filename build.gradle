buildscript{
    dependencies{
        classpath "com.github.Anuken.Arc:arc-core:$arcVersion"
    }

    repositories{
        // Necessary Maven repositories for build script classpath.
        mavenCentral()
        maven{url 'https://www.jitpack.io'}
        maven{url 'https://raw.githubusercontent.com/Zelaux/MindustryRepo/master/repository'}
    }
}

import arc.files.*
import arc.graphics.*
import arc.util.*
import arc.util.io.*
import arc.util.serialization.*
import groovy.transform.*

import java.util.concurrent.atomic.*

configure(allprojects){
    apply plugin: 'java'

    // Main source directory.
    sourceSets.main.java.srcDirs = ['src/']
    dependencies{
        // Downgrade Java 9+ syntax into being available in Java 8.
        annotationProcessor "com.github.GlennFolker.EntityAnno:downgrader:$entVersion"
    }

    repositories{
        // Necessary Maven repositories to pull the dependencies.
        mavenCentral()
        maven{url 'https://www.jitpack.io'}
        maven{url 'https://raw.githubusercontent.com/Zelaux/MindustryRepo/master/repository'}
    }

    // Use Java 17 syntax, but target Java 8 bytecode version.
    tasks.withType(JavaCompile).configureEach{
        sourceCompatibility = JavaVersion.current().ordinal() - JavaVersion.VERSION_17.ordinal() + 17
        options.release.set 8
        options.compilerArgs << '-Xlint:-options'

        options.incremental = true
        options.encoding = 'UTF-8'
    }

    // Force Arc version to be the same.
    configurations.configureEach{
        resolutionStrategy.eachDependency{
            if(requested.group == 'com.github.Anuken.Arc'){
                useVersion arcVersion
            }
        }
    }
}

@CompileStatic
void fetchSprites(String mindustryVersion, File baseDir){
    final def amount = new AtomicInteger(1), total = new AtomicInteger(0)
    Http.get("https://api.github.com/repos/Anuken/Mindustry/contents/core/assets-raw/sprites/units?ref=$mindustryVersion")
        .timeout(0)
        .error{throw new RuntimeException(it)}
        .block{response(baseDir, amount, total, it)}

    while(amount.get() > 0) Thread.yield()
    logger.lifecycle "Fetched ${total.get()} unit sprites"
}

@CompileStatic
void response(File dir, AtomicInteger amount, AtomicInteger total, Http.HttpResponse res){
    final def list = Jval.read(res.resultAsString).asArray()
    amount.addAndGet(list.size)

    for(final def val : list){
        final def name = val.getString('name')
        switch(val.getString('type')){
            case 'file':
                Http.get(val.getString('download_url'))
                    .timeout(0)
                    .error{throw new RuntimeException(it)}
                    .submit{
                        if(name.endsWith('.png')){
                            final def image = new Pixmap(Streams.copyBytes(it.resultAsStream))
                            new Fi(file("$dir/$name")).writePng(image)
                        }

                        total.addAndGet(1)
                        amount.addAndGet(-1)
                    }
                break
            case 'dir':
                Http.get(val.getString('url'))
                    .timeout(0)
                    .error{throw new RuntimeException(it)}
                    .submit{response(file("$dir/$name"), amount, total, it)}
                break
        }
    }

    amount.addAndGet(-1)
}

configure(project(':proc')){
    tasks.register('fetchSprites'){
        final def fetchOutputProv = layout.buildDirectory.dir('fetched')
        doFirst{
            def fetchOutput = fetchOutputProv.get().asFile
            fetchOutput.deleteDir()
            fetchOutput.mkdir()

            fetchSprites(mindustryVersion, fetchOutput)
            file("$fetchOutput/cache.txt").text = mindustryVersion
        }

        outputs.dir fetchOutputProv
        outputs.upToDateWhen{
            def fetchOutput = fetchOutputProv.get().asFile
            def cache = file("$fetchOutput/cache.txt")
            cache.exists() && cache.text == mindustryVersion
        }
    }

    tasks.register('genSprites', JavaExec){
        dependsOn fetchSprites, configurations.runtimeClasspath

        final def genOutputProv = layout.buildDirectory.dir('output')
        final def fetchSpritesProv = layout.buildDirectory.dir('fetched')

        mainClass = 'lights.gen.Generator'
        classpath = sourceSets.main.runtimeClasspath
        standardInput = System.in
        workingDir = genOutputProv

        doFirst{
            def genOutput = genOutputProv.get().asFile
            genOutput.deleteDir()
            genOutput.mkdir()

            args fetchSpritesProv.get().asFile
        }

        doLast{
            def genOutput = genOutputProv.get().asFile
            file("$genOutput/cache.txt").text = mindustryVersion
        }

        outputs.dir genOutputProv
        outputs.upToDateWhen{
            def genOutput = genOutputProv.get().asFile
            def cache = file("$genOutput/cache.txt")
            cache.exists() && cache.text == mindustryVersion
        }
    }

    dependencies{
        // Depend on Mindustry/Arc classpath.
        implementation "com.github.Anuken.Mindustry:core:$mindustryVersion"
        implementation "com.github.Anuken.Arc:arc-core:$arcVersion"
        implementation "com.github.Anuken.Arc:natives-desktop:$arcVersion"
    }
}

configure(rootProject){
    jar{
        inputs.files project(':proc').tasks.genSprites
        archiveFileName = "${rootProject.name}-Desktop.jar"

        from files(sourceSets.main.output.classesDirs)
        from files(sourceSets.main.output.resourcesDir)
        from configurations.runtimeClasspath.collect{it.isDirectory() ? it : zipTree(it)}

        from files(layout.projectDirectory.file('assets'))
        from files(project(':proc').layout.projectDirectory.file('output')){
            exclude 'cache.txt'
        }
    }

    tasks.register('dex', Jar){
        inputs.files tasks.jar
        archiveFileName = "${rootProject.name}.jar"

        final def desktopJar = tasks.jar.archiveFile
        final def dexJar = file("$temporaryDir/Dexed.jar")

        from zipTree(desktopJar), zipTree(dexJar)
        doFirst{
            def sdkRoot = file(
                System.getenv('ANDROID_SDK_ROOT') ?: System.getenv('ANDROID_HOME') ?:
                { throw new GradleException('Neither `ANDROID_SDK_ROOT` nor `ANDROID_HOME` is set') }
            )

            def d8 = file("$sdkRoot/build-tools/$androidBuildVersion/d8")
            if(!d8.exists()){
                throw new GradleException("Android SDK `build-tools;$androidBuildVersion` isn't installed or is corrupted")
            }

            def input = desktopJar.get().asFile
            def command = "$d8 --release --min-api $androidMinVersion --output $dexJar $input"

            (configurations.compileClasspath.asList() + configurations.runtimeClasspath.asList()).forEach{
                if(it.exists()) command = "$command --classpath $it"
            }

            def androidJar = file("$sdkRoot/platforms/android-$androidSdkVersion/android.jar")
            if(!androidJar.exists()){
                throw new GradleException("Android SDK `platforms;android-$androidSdkVersion` isn't installed or is corrupted")
            }

            command = "$command --lib $androidJar"
            if(OS.isWindows) command = "cmd /c $command"

            logger.log(LogLevel.LIFECYCLE, 'Running `d8`.')
            command.execute(null, layout.projectDirectory.asFile).waitForProcessOutput(System.out, System.err)
        }
    }

    dependencies{
        // Depend on Mindustry/Arc classpath.
        compileOnly "com.github.Anuken.Mindustry:core:$mindustryVersion"
        compileOnly "com.github.Anuken.Arc:arc-core:$arcVersion"
    }
}
